<?DOCTYPE html>
<html lang="en"> 
  <head>
    <script
      async
      src="https://www.googletagmanager.com/gtag/js?id=G-WPJ8DCJ6YV"
    ></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag() {
        dataLayer.push(arguments);
      }
      gtag("js", new Date());

      gtag("config", "G-WPJ8DCJ6YV");
    </script>

    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>

    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/languages/python.min.js"></script>
    <script>
      hljs.highlightAll();
    </script>

    <title>EvoGenesis</title> 
    <link rel="icon" href="Media/Icon.ico" type="image/x-icon" /> <link rel="shortcut icon" href="Media/Icon.ico" type="image/x-icon" />

    <link rel="stylesheet" href="simulation_style.css" />
    <link rel="stylesheet" href="navbar-stylesheet.css" />

    <meta charset="UTF-8" />
    <meta
      name="keywords"
      content="Evolution, Simulation, Genesis, Evogenesis, EvoGenesis, EVOGENESIS"
    />
    <meta
      name="description"
      content="EvoGenesis Evolution Simulation information and download"
    />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script
      async
      src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9825750258636586"
      crossorigin="anonymous"
    ></script>
  </head>
  <body>

    <div id="navbar">
      <a href="index.html" class="navbar-elements">Home</a>
      <a href="tutorials.html" class="navbar-elements">Tutorials</a>
      <div id="dropdown">
        <button id="dropbtn-current-page">Products &#x25BC;</button>
        <div id="dropdown-content">
          <a href="simulation.html">Evolution Simulation</a>
        </div>
      </div>
      <a href="mysetup.exe" class="navbar-elements" id="download-button"
        >Download Evolution Simulator</a
      >
      <h5 id="current-username"></h5>
      <button id="taskbarimagebutton">
        <img src="Media/Icon.ico" alt="Icon" id="taskbarimage" height="50" />
      </button>
    </div>

    <br />
    <br />

    <div class="container" id="main-container">
      <div id="demo">
        <div id="demo-video-container">
          <video id="demoVideo" width="100%" autoplay>
            <source src="Media/Full.mp4" type="video/mp4">
          </video>
        </div>
      </div>
      <div id="controls-explanation">
        <h1>Evolution Simulation - Experience Evolution in Real Time</h1>
        <h5>An Evogenesis product</h3>
        <h2>Features</h2>
        <ul>
          <li>Real-time simulation of amoebas and plants interacting in their environment</li>
          <li>Advanced graphics and accurate simulation algorithms for a realistic experience</li>
          <li>Detailed graphs and charts that show the evolution and adaptation of the organisms</li>
          <li>Adjustable settings to customize the simulation to your liking</li>
          <li>Fun and educational for all ages</li>
        </ul>

        <a href="mysetup.exe" class="navbar-elements" id="download-button" style="margin-left: 25%"
        >Download Evolution Simulator</a>
        <br />
        <br />
        <p id="github-link-flex-p">Github Repository: <a href="https://github.com/Shbc314159/Evolution-Simulation-Python"><img src="Media/github-icon.png" width="50" height="50"/></a></p>
      </div>
    </div>

    <div class="container">
      <div id="videos1">
        <figure>
          <video class="video" autoplay loop>
            <source src="Media/Single Amoeba.mp4" type="video/mp4" />
            Your browser does not support the video tag.
          </video>
          <figcaption><i>Figure 1: The First Amoeba</i></figcaption>
        </figure>

        <figure>
          <video class="video" autoplay loop>
            <source src="Media/Color + Reproduction.mp4" type="video/mp4" />
            Your browser does not support the video tag.
          </video>
          <figcaption><i>Figure 3: Evolving Amoebae</i></figcaption>
        </figure>

        <figure>
          <video class="video" autoplay loop>
            <source src="Media/Plants.mp4" type="video/mp4" />
            Your browser does not support the video tag.
          </video>
          <figcaption><i>Figure 5: A Fragile Ecosystem</i></figcaption>
        </figure>
      </div>

      <div id="text">
        <h1 id="title-dev">Development</h1>

        <p class="dev-text">
          The idea started with a tutorial. During a Computer Science class, I
          had just finished learning about Python Object Oriented Programming
          and I decided to create a game. Thanks to this tutorial:
          <a href="https://realpython.com/pygame-a-primer/"
            >A Primer on Pygame</a
          >, I was quickly able to recreate Figure 1. But instead of trying to
          then create a game with it, I was struck by how lifelike the
          <a href="https://docs.python.org/3/library/random.html">random</a>
          movement looked.
        </p>
        <br />
        <p class="dev-text">
          This then reminded me of amoebae (we had been studying microorganisms
          in Biology) and somehow I then had the idea of simulating their
          evolution. I then added a for loop to the code to create a whole host
          of
          <a href="https://www.grammar-monster.com/plurals/plural_of_amoeba.htm"
            >amoebae</a
          >
          (see Figure 2).
        </p>

        <br />

        <p class="dev-text">
          The next task seemed complex but was ultimately simple: to make the
          amoebae evolve. After trying to implement a gene-based structure
          modelled on actual DNA, I opted for a value passed down from parent to
          child. This value would be the amoebae's maturing speed. In order for
          two amoebas to reproduce, they must both have a 'maturity' above a
          certain value, which was incremented every 'second' of their lives.
          Those with higher maturing speeds would attain the necessary maturity
          faster. To prevent the amoebae reproducing extremely quickly and
          crashing my computer, I first had to implement an age attribute that
          would, like maturity, increment each second and then kill any amoebae
          older than a certain value. I also reset the maturity of each amoeba
          after they reproduced.
        </p>

        <br />

        <p class="dev-text">
          To allow evolution to be visualised more easily, I set each amoeba's
          colour to their maturing speed: the darker they were, the lower their
          maturing speed (Figure 3). However, this proved to be an inadequate
          method so I opted for a graph-based approach insted.
        </p>

        <br />

        <p class="dev-text">
          Implementing the graph, like many steps of this process, was
          surprisingly simple and easily one of the most satisfying parts of it.
          However, I then made the ill-fated mistake of trying to work out an
          equation for the changing maturing speed of the amoebae. There were
          two issues with this: not only were there five central variables
          (mutation constant, death age, maturing age, speed and maximum
          population), the entire process was inherently random.
        </p>

        <br />

        <p class="dev-text">
          Now, the project seemed finished. I'd done what I set out to do -
          simulate evolution. But I wanted this to become slightly more
          realistic, so I thought I'd add in plants. This added a lot more
          complexity to the program, both in terms of the actual code and the
          fragility of the ecosystem. Nine times out of ten, either the amoebeae
          would die off or the plants would (and since the amoebae fed off them,
          they eventually died too). There were also far more constants to
          tinker with.
        </p>

        <br />

        <p class="dev-text">
          After trying to find some set of constants that would create a
          balance, I realised that again, due to the inherent complexity and
          randomness of the program, some degree of user control would be
          necessary to maintain its stability. And actually, this wouldn't be
          such a bad thing. After all, if this was to be used as a learning
          resource, surely it would be much more effective if it were an
          actively used one?
        </p>

        <br />

        <p class="dev-text">
          And so I set out on the most time-consuming aspect of all: the
          graphical user interface.
        </p>

        <br />

        <p class="dev-text">
          Without going into the details, this was essentially complicated
          because I had to create a mechanism by which both the simulation and
          the graphs could be drawn onto a separate window whilst losing as
          little performance as possible. And of <i>course</i> many of the
          <a
            href="https://careerfoundry.com/en/blog/web-development/programming-library-guide/#:~:text=A%20programming%20library%20is%20a,few%20different%20pre%2Dcoded%20components."
            >libraries</a
          >
          I used creating this were incompatible, so I had to work around that.
          Once the user interface was finished, I added some extra user control
          and spruced it up a bit. The original UI library looks like it dropped
          out of the 1980s so some modification was necessary.
        </p>

        <br />

        <p class="dev-text">And so this is it!</p>
      </div>

      <div id="videos2">
        <figure id="multiple-amoebas-fig">
          <video class="video" autoplay loop>
            <source src="Media/Multiple Amoebas.mp4" type="video/mp4" />
            Your browser does not support the video tag.
          </video>
          <figcaption><i>Figure 2: Multiple Amoebas</i></figcaption>
        </figure>

        <figure>
          <div id="graph-video-container">
            <video class="video" id="graph-video" autoplay loop>
              <source src="Media/Graph.mp4" type="video/mp4" />
              Your browser does not support the video tag.
            </video>
          </div>
          <br />
          <figcaption><i>Figure 4: A graphical visualisation</i></figcaption>
        </figure>

        <div id="extra-notes">
          <h1>Notate Bene</h1>

          <p>
            Just a couple of extra notes about the making of this.
            <br />
            <br />
            Firstly, I said several times that many of these features were
            surprisingly quick to implement. The reason, therefore, why this
            project was very time consuming, was that optimisation and debugging
            took up approximately 70-80% of the time I spent on this project*.
            This is because I was mostly teaching myself all of this material as
            I went along and also because as soon as I added the GUI the project
            started ballooning in size.
          </p>

          <br />

          <p>
            Also a further note about the fragility of the ecosystem. The irony
            that a simulation of evolution (which is the mechanism by which
            ecosystems survive in changing conditions) is itself unstable is not
            lost on me. Unfortunately when this idea came to mind I rejected it
            and later the project became too convoluted to risk attempting it.
            <br />
            <br />
            I did concieve how this could work, however.
            <br />
            <br />
            Firstly, each amoeba would have a 'genes' attribute, which would be
            a long string of bases. Upon their birth, this string would be
            parsed by a function and then based on the results their phenotype
            (attributes like their speed, death age etc) would be created. When
            they reproduced, their child's genes would be created by randomly
            selecting bases from their genes and their mate's.
            <br />
            <br />
            Now the issues. Ignoring the complexity of it, this model leaves no
            room for the creation of new genes - a vital part of evolution.
            Secondly, the parser would be difficult to create. In nature there
            are many stages between the DNA sequence and the organism's
            phenotype. Whilst this model would be far simpler, it would also be
            impossible for the same complexity of evolution to be replicated -
            for example, the amoebae couldn't evolve into a completely different
            species with different behaviours.
            <br />
            <br />
            So although this model would be more accurate than my current
            implementation, and the results would certainly be very interesting,
            to create true evolution advanced deep learning would have to be
            used. This would enable the species to actually create new genes
            which have not been coded into it. This is an exciting concept but
            perhaps a project for when my skills are more advanced.
            <br />
            *Overall I estimate it took me about 175-200 hours
          </p>

          <br />

          <p>
            In conclusion to this fairly lengthy tangent, I would like to say
            this: we are taught that evolution is an explanation of how life on
            Earth can have developed such complexity without a fantastical
            degree of chance being needed. However, based on my (very small)
            experience I would argue this is untrue: for every single minute new
            development an organism not only was fortunate enough to mutate in a
            beneficial way, it was also fortunate enough to be able to make use
            of that. Perhaps an eye could evolve without a great degree of luck,
            but it is absolutely useless without a brain. And how fortunate must
            an organism to develop both of these seemingly useless appendages at
            once!
          </p>
        </div>
      </div>
    </div>

    <video class="video" id="full-video" autoplay loop>
      <source src="Media/Full.mp4" type="video/mp4" />
      Your browser does not support the video tag.
    </video>

    <div id="code">
      <p id="code-title">
        This is an earlier iteration of the code, I have added it here with
        heavy commenting in case anyone else just wanted to get some idea of
        what went into this.
      </p>
      <pre>
        <code contenteditable spellcheck="false" class="hljs python">
    #import relevant modules
    import pygame 
    import random
    import time
    import itertools
    import matplotlib.pyplot as plt
    import matplotlib.animation as animation
    import numpy
    import keyboard

    from pygame.locals import (
        QUIT
    )

    #define constants
    SCREEN_WIDTH = 500
    SCREEN_HEIGHT = 500
    MUTATION_CONSTANT = int(input("Please enter the desired mutation speed: "))
    DEATH_AGE = 500
    MATURING_AGE = 50
    SPEED = 3
    POPULATION = 100

    #initialise variables, pygame, the screen and the amoeba group
    global num_collisions
    num_collisions = 0

    pygame.init()   
    screen = pygame.display.set_mode([SCREEN_WIDTH, SCREEN_HEIGHT])
    amoebas = pygame.sprite.Group()

    #create the amoeba class which inherits from the pygame sprite class
    #this base class contains several objects that are very commonly used,
    #such as image (which is how self.surf is defined) and rect
    class Amoeba(pygame.sprite.Sprite):
        id_iter = itertools.count() #iterator giving each sprite a unique id

        def __init__(self, maturing_speed, x, y):
            super().__init__() #initialise pygame.sprite.Sprite attributes
            self.id = 'amoeba' + str(next(Amoeba.id_iter)) #unique id
            self.surf = pygame.Surface((10, 10)) #each player will be a 10x10 square
            self.maturing_speed = maturing_speed #inherited value
            color = max(min(self.maturing_speed, 254), 1)
            #negative color values (there are negative maturing speed values) cause issues
            self.surf.fill((color, 0, 0)) #give the square color
            self.rect = self.surf.get_rect(center=(x, y,)) #the position is based on inherited values
            self.speed = SPEED
            self.maturity = 0
            self.age = 0
            
        #called for every sprite on each iteration of the game loop
        def update(self):
            #stops sprite going off screen
            if self.rect.left <= 0:
                direction = 1
            elif self.rect.right >= SCREEN_WIDTH: 
                direction = 2
            elif self.rect.top <= 0:
                direction = 3
            elif self.rect.bottom >= SCREEN_HEIGHT:
                direction = 4
            else:
                direction = random.randint(1, 4) #random movement

            #sprite is moved based on speed and direction
            #move_ip is used to update the sprite's position
            #the move method actually creates a new object which takes a lot more memory
            if direction == 1:
                self.rect.move_ip(self.speed, 0)
            elif direction == 2:
                self.rect.move_ip(-self.speed, 0)
            elif direction == 3:
                self.rect.move_ip(0, self.speed)
            elif direction == 4:
                self.rect.move_ip(0, -self.speed)
                
            if self.age >= DEATH_AGE:
                self.kill() #wipes the sprite from the screen and the group. neat name

            self.age = self.age + 1

            #this expression basically determines how much of an effect maturing speed has
            #so I experimented with it a lot but settled on quite a simple approach
            self.maturity = self.maturity + (self.maturing_speed/125)

            #used to control amoeba population to stop it crashing my computer (happened a LOT)
            if len(amoebas) > POPULATION:
                self.kill()

        #decorator to make this apply not to individual instances but the class as a whole.
        #doesn't really need to be part of the class but it makes the code more organised.
        @classmethod
        def collide(cls, num_collisions): #cls replaces self as a representation of the class (e.g. Amoeba)
            #this is why I used an iterator. as the group size grows to hundreds or thousands it's far more efficient
            #as it doesn't use permutations and also has a more efficient algorithm
            for amoeba_1, amoeba_2 in itertools.combinations(amoebas, 2): 
                if amoeba_1.maturity >= MATURING_AGE and amoeba_2.maturity >= MATURING_AGE and (
                    pygame.sprite.collide_rect(amoeba_1, amoeba_2) #more than one way to check collision however
                ):
                    amoeba_1.maturity = 1 #reset maturites
                    amoeba_2.maturity = 1

                    #don't want the offspring too close as it causes the amoebas to bunch and reproduce very fast
                    location_x = amoeba_1.rect.left + random.randint(-10,20) 
                    location_y = amoeba_1.rect.top + random.randint(-10,20)

                    #this is where the mutation happens
                    speed_low = min(amoeba_1.maturing_speed, amoeba_2.maturing_speed) - MUTATION_CONSTANT
                    speed_high = max(amoeba_1.maturing_speed, amoeba_2.maturing_speed) + MUTATION_CONSTANT
                    
                    new_maturing_speed = random.randint(speed_low, speed_high)
                    
                    amoebas.add(cls(new_maturing_speed, location_x, location_y)) #cls can be replaced with Amoeba
                    num_collisions += 5 #should be 1 but this means it is more visible on the graph
                    
            return num_collisions
        

    def main():
        
        plt.ion() #interactive mode on for the graph which lets it be updated in real time.

        fig, ax = plt.subplots() #create figure and axi objects

        xpoints = []
        ypoints1 = [] #maturing speed line
        ypoints2 = [] #num collisions line

        line1, = ax.plot(xpoints, ypoints1, "-b", label="Average Maturing Speed")
        line2, = ax.plot(xpoints, ypoints2, "-r", label="Reproduction rate (/100 seconds)")
        ax.legend(loc="upper left") #key
        
        screen.fill((255, 255, 255))

        for i in range(POPULATION): #create initial amoeba population
            amoeba = Amoeba(random.randint(25, 50), random.randint(0, SCREEN_WIDTH), random.randint(0, SCREEN_HEIGHT))
            amoebas.add(amoeba)


        step_counter = 0 #again, used to help num_collisions to be more visible (it's a cumilative value)
        total = 0
        num_collisions = 0
        
        while True:    
            total = 0 #reset maturing speed total
            
            step_counter += 1 #increment counter

            for amoeba in amoebas: #iterate through group
                total = total + amoeba.maturing_speed

            if step_counter % 20 == 0: #this means that num_collisions is about 20x larger than its real value
                ypoints2.append(num_collisions)
                num_collisions = 0
            elif len(ypoints2) > 1: #keep previous value if no new value is added
                ypoints2.append(ypoints2[len(ypoints2) - 1])
            else:
                ypoints2.append(0) #only used for the first few values
                
            xpoints.append(step_counter) #time
            ypoints1.append(total/len(amoebas)) #average maturing speed

            line1.set_data(xpoints,ypoints1)
            line2.set_data(xpoints,ypoints2)
            ax.relim() #makes axes data limits larger/smaller based on current datasets
            ax.autoscale_view() #makes view limits fit data limits
            fig.canvas.draw() #redraws graph
            fig.canvas.flush_events() #updates it immediately
                  
            if keyboard.is_pressed('q'):
                print(ypoints1[len(ypoints1)-1]/xpoints[len(xpoints)-1]) #used to help with testing - prints out maturing speed/time
                
            screen.fill((255, 255, 255))

            amoebas.update()

            num_collisions = Amoeba.collide(num_collisions) #so num_collisions is cumilative

            for amoeba in amoebas:
                screen.blit(amoeba.surf, amoeba.rect) #draws amoebas on screen 

            pygame.display.flip() #updates display

        pygame.quit() #there isn't a breakout from the while loop so this does nothing. I'd recommend adding one if you use it.


    #just a useful statement that enables the program to be used as a module without running main() automatically
    if __name__ == '__main__':
        main()

          </code>
        </pre>
    </div>

    <script src="taskbarbutton.js" type="text/babel"></script>
  </body>
</html>
